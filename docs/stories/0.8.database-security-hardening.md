# <!-- Powered by BMAD™ Core -->

# Story 0.8: Database Security Hardening

## Parent Epic

**Epic 1: Foundation & Privacy Infrastructure** - Database security hardening directly implements Epic 1, Story 1.1 requirements for comprehensive database security setup including RLS policies, connection security, and audit logging as foundational privacy infrastructure.

## Status

**Approved**

## Story

**As a** zero-knowledge architecture implementer,  
**I want** Supabase RLS policies configured with "deny-by-default" principle,  
**so that** data access is impossible without explicit user authorization.

## Acceptance Criteria

1. **Row Level Security (RLS) Implementation**
   - All database tables configured with RLS enabled by default
   - Deny-by-default policies: no data access without explicit user authorization
   - User isolation policies preventing cross-user data access under any circumstance
   - Service role policies restricted to only non-PII operations (health checks, migrations)

2. **Database Connection Security**
   - SSL/TLS encryption enforced for all database connections
   - Certificate pinning implemented for mobile and web clients
   - Connection pooling configured with security-first settings
   - Database firewall rules restricting access to authorized IP ranges

3. **Audit and Monitoring**
   - Audit logging enabled for all database access attempts and policy violations
   - Real-time alerting on RLS policy violations or unusual access patterns
   - Database query monitoring for potential SQL injection or privilege escalation
   - Regular access review and permission auditing automation

4. **Encryption and Key Management**
   - Database encryption at rest verified with customer-managed keys
   - Column-level encryption for highly sensitive fields (if applicable)
   - Key rotation policies and procedures documented
   - Backup encryption and secure key escrow procedures

5. **RLS Policy Testing**
   - Comprehensive test suite with negative test cases (attempted unauthorized access)
   - Automated testing of RLS policies in CI/CD pipeline
   - Penetration testing scenarios for database access controls
   - Policy regression testing to prevent accidental privilege escalation

## Tasks / Subtasks

- [ ] **Task 1: Database Schema RLS Implementation** (AC: 1)
  - [ ] Create migration {next_sequence_number}\_rls_policies.sql with RLS enabled for all tables
  - [ ] Implement deny-by-default RLS policies for encrypted_cycle_data table
  - [ ] Implement deny-by-default RLS policies for encrypted_user_prefs table
  - [ ] Implement deny-by-default RLS policies for healthcare_share table
  - [ ] Implement deny-by-default RLS policies for share_token table
  - [ ] Implement deny-by-default RLS policies for device_key table
  - [ ] Configure service role policies with explicit operation restrictions:
    - SELECT on table metadata (table_name, column_name, is_nullable) for schema validation
    - INSERT/UPDATE/DELETE on migration_history table for deployment tracking
    - EXECUTE on health_check functions (connection_status, db_version)
    - SELECT on system catalogs (pg_stat_database, pg_tables) for monitoring
    - NO ACCESS to any user data tables (encrypted_cycle_data, encrypted_user_prefs, etc.)
    - NO ACCESS to any authentication tables or user session data
  - [ ] Document RLS policy structure and user isolation principles

- [ ] **Task 2: Database Connection Security Configuration** (AC: 2)
  - [ ] Configure Supabase SSL/TLS enforcement with minimum TLS 1.3
  - [ ] Implement certificate pinning in mobile apps (iOS/Android secure storage)
  - [ ] Implement certificate pinning in web app with fallback mechanisms
  - [ ] Configure Supabase connection pooling with security-first settings
  - [ ] Set up database firewall rules restricting access to authorized IPs
  - [ ] Test connection security across all client platforms

- [ ] **Task 3: Audit and Monitoring Implementation** (AC: 3)
  - [ ] Create secure RPC function healthcare_access_audit.sql for audit logging
  - [ ] Configure Supabase audit logging for policy violations and access attempts
  - [ ] Set up real-time alerting for RLS policy violations via Sentry integration
  - [ ] Implement database query monitoring for security threat detection
  - [ ] Create automated access review procedures with quarterly scheduling
  - [ ] Document incident response procedures for security violations

- [ ] **Task 4: Encryption and Key Management Hardening** (AC: 4)
  - [ ] Verify Supabase encryption at rest with customer-managed keys configuration
  - [ ] Document column-level encryption strategy for highly sensitive fields
  - [ ] Create key rotation policies and automated procedures documentation
  - [ ] Implement secure backup encryption with key escrow procedures
  - [ ] Configure automated key rotation scheduling and monitoring
  - [ ] Test key recovery and disaster recovery procedures

- [ ] **Task 5: RLS Policy Testing Suite** (AC: 5)
  - [ ] Create rls-policy-enforcement.test.ts with comprehensive RLS validation tests
  - [ ] Create user-isolation.test.ts with cross-user access prevention scenarios
  - [ ] Create service-role-restrictions.test.ts validating service account limitations
  - [ ] Create negative-access-attempts.test.ts with unauthorized access scenarios
  - [ ] Create connection-security.test.ts for SSL/TLS and certificate pinning validation
  - [ ] Create automated-penetration-tests.sh for systematic security testing
  - [ ] Implement automated RLS policy testing in CI/CD pipeline (GitHub Actions)
  - [ ] Set up continuous security testing with rls-bypass-attempts.ts
  - [ ] Document security test procedures and pass/fail criteria

## Dev Notes

### Architecture Context

This story implements comprehensive database security hardening as specified in [Source: architecture/security-and-performance.md] security requirements and builds upon the zero-knowledge architecture principles established in [Source: architecture/data-models.md] to ensure complete user data isolation through Row Level Security policies.

### Previous Story Insights

From Story 0.7 completion (Comprehensive Threat Model Creation):

- **Critical Database Threats Identified**: 4 Critical threats (400+ risk score) directly related to database security require mitigation
- **Zero-Knowledge Architecture Validation**: Threat model confirms that proper RLS implementation mitigates most critical server-side data access threats
- **User Isolation Requirements**: Cross-user data access prevention identified as highest priority security control
- **Regulatory Compliance Framework**: GDPR, HIPAA compliance requires auditable database access controls with policy violation detection

Key Insights from Threat Model:

- Family Member Device Access (Risk Score: 450) requires device-level authentication but database isolation prevents server-side cross-user access
- State Reproductive Health Investigations (Risk Score: 450) mitigated by zero-knowledge architecture with proper RLS policies
- Database compromise scenarios require defense-in-depth with encryption at rest, RLS policies, and audit logging
- Server breach attack trees identified privilege escalation through RLS policy bypass as critical vulnerability

### Data Models and RLS Requirements [Source: architecture/data-models.md]

**User Data Isolation Architecture:**

All database tables implement user isolation through RLS policies using `auth.uid()`:

**EncryptedUserPrefs Table:**

- RLS Policy: `userId = auth.uid()` - users can only access their own preferences
- Service Role Restriction: Explicitly limited to schema metadata, migration tracking, health checks, and system monitoring. Completely prohibited from accessing encrypted payloads, user data, or authentication information

**EncryptedCycleData Table:**

- RLS Policy: `userId = auth.uid()` - complete user data isolation
- Version Control: Optimistic concurrency prevents data corruption
- Sync Status: Device-specific tracking without cross-user exposure

**HealthcareShare Table:**

- RLS Policy: `userId = auth.uid()` - sharing creator control only
- Token-based Access: Separate ShareToken table with token-based RLS
- Audit Integration: All access attempts logged without PII exposure

**DeviceKey Table:**

- RLS Policy: `userId = auth.uid()` - device key isolation per user
- Key Rotation: Automated rotation without cross-user key exposure
- Device Management: Hash-based device identification for privacy

**ShareToken Table (Separate RLS):**

- RLS Policy: `token = supplied_token AND expiresAt > NOW()` - token-based access only
- No User Reference: Prevents user enumeration through token validation
- Time-based Expiration: Automatic access revocation

### Database Security Configuration [Source: architecture/backend-architecture.md]

**Supabase Connection Security:**

Connection string requirements:

```
postgresql://postgres:[password]@[host]:5432/postgres?sslmode=require&sslcert=client-cert.pem&sslkey=client-key.pem&sslrootcert=ca-cert.pem
```

**Repository Pattern with RLS Enforcement:**

```typescript
class CycleDataRepository {
  async updateWithOptimisticConcurrency(
    recordId: string,
    encryptedPayload: string,
    cryptoEnvelope: CryptoEnvelope,
    currentVersion: number,
    deviceIdHash: string
  ): Promise<UpdateResult> {
    // All operations automatically enforce RLS through auth.uid()
    const { data, error } = await this.supabase.rpc('update_cycle_data_optimistic', {
      record_id: recordId,
      new_payload: encryptedPayload,
      new_envelope: cryptoEnvelope,
      current_version: currentVersion,
      device_hash: deviceIdHash,
    });
  }
}
```

### RLS Implementation Strategy [Source: architecture/source-tree.md]

**File Structure for Database Security:**

```
db/
├── migrations/
│   ├── 002_rls_policies.sql          # RLS policy implementation
│   ├── 003_secure_functions.sql      # Secure RPC functions with RLS
│   └── 004_indexes.sql               # Performance indexes with security
├── policies/                         # RLS policy definitions
│   ├── cycle_data.sql               # Cycle data user isolation
│   ├── user_prefs.sql              # User preferences isolation
│   └── healthcare_share.sql        # Healthcare sharing security
└── functions/                       # Secure RPC functions
    ├── update_cycle_data_optimistic.sql  # Optimistic concurrency with RLS
    ├── validate_share_token.sql          # Token validation without user exposure
    └── healthcare_access_audit.sql       # Privacy-safe audit logging
```

### Security Performance Requirements [Source: architecture/security-and-performance.md]

**Database Performance with Security:**

- **Response Time Target**: <200ms for API calls with RLS enforcement
- **Rate Limiting**: 100 requests/minute per IP, 1000/hour per authenticated user
- **Database Optimization**: Composite indexes on (user_id, updated_at DESC) to support RLS queries efficiently
- **Connection Pooling**: Security-first settings with connection limits and timeout configuration

**Authentication Security Integration:**

- **Token Storage**: Secure HTTP-only cookies for web, iOS Keychain/Android Keystore for mobile
- **Session Management**: JWT with 24-hour expiration integrated with RLS auth.uid() validation
- **Certificate Pinning**: Implemented for all database connections to prevent MITM attacks

### Critical Security Controls Implementation [Source: architecture/coding-standards.md]

**Zero-Knowledge Principle Enforcement:**

- Server must never access plaintext health data through RLS policy design
- All database queries must use `auth.uid()` for user isolation
- Input sanitization with Zod schemas before RLS-enforced database operations

**AAD Validation in Database Operations:**

- All crypto operations must include Additional Authenticated Data validation
- Database RLS policies integrate with crypto envelope validation
- Audit trail maintains privacy-safe logging without PII exposure

**Audit Trail Requirements:**

- All healthcare sharing activities logged with privacy-safe metadata only
- RLS policy violations generate real-time alerts through Sentry integration
- Database query monitoring detects potential privilege escalation attempts

### Testing Standards [Source: architecture/tech-stack.md]

**Database Security Testing Framework:**

- **Testing Framework**: Vitest + Supertest for API testing with RLS validation
- **Security Testing Tools**: Custom RLS testing framework with unauthorized access attempts
- **CI/CD Integration**: GitHub Actions with automated security gate validation
- **Penetration Testing**: Manual and automated testing of RLS policy bypass attempts

**Test Coverage Requirements:**

- **RLS Policy Tests**: 100% negative test coverage for unauthorized access prevention
- **Integration Tests**: API endpoint testing with valid and invalid authentication scenarios
- **Performance Tests**: RLS query performance validation under load
- **Regression Tests**: Automated detection of RLS policy changes that reduce security

**Specific Test File Locations:**

```
apps/web/src/__tests__/security/rls/
├── rls-policy-enforcement.test.ts           # RLS policy validation tests
├── user-isolation.test.ts                   # Cross-user access prevention tests
├── service-role-restrictions.test.ts        # Service role limitation tests
└── negative-access-attempts.test.ts         # Unauthorized access attempt tests

apps/web/src/__tests__/api/database/
├── connection-security.test.ts              # SSL/TLS and certificate pinning tests
├── audit-logging.test.ts                    # Security event logging tests
├── query-monitoring.test.ts                 # SQL injection and privilege escalation tests
└── performance-with-rls.test.ts             # Database performance under RLS enforcement

packages/shared-types/src/__tests__/
├── crypto-envelope-validation.test.ts       # Crypto envelope type validation
└── database-schema-types.test.ts            # Database schema TypeScript type validation

scripts/security-test-suite/
├── automated-penetration-tests.sh           # Automated security testing scripts
├── rls-bypass-attempts.ts                   # RLS policy circumvention tests
└── security-regression-tests.ts             # Policy regression detection tests
```

### Project Structure Alignment

Database security implementation aligns with established project architecture:

- **Migration Strategy**: Supabase CLI-based migrations with version control and staging/production parity
- **RPC Function Security**: TypeScript RPC functions with RLS enforcement and input validation
- **Audit Integration**: Sentry privacy-safe configuration for security violation monitoring
- **Multi-platform Support**: Certificate pinning implementation across web, iOS, and Android clients

### Critical Implementation Requirements

**RLS Policy Design Principles:**

1. **Deny-by-Default**: No data access without explicit user authorization
2. **User Isolation**: `auth.uid()` enforcement prevents all cross-user access
3. **Service Role Limitation**: System operations limited to non-PII metadata only
4. **Audit Integration**: All policy violations logged without PII exposure
5. **Performance Optimization**: Efficient indexing strategy supporting RLS query patterns

**Security Gate Requirements:**

- All RLS policies must pass 100% negative testing (unauthorized access attempts)
- Certificate pinning must be validated across all client platforms
- Audit logging must capture security events without PII leakage
- Database encryption at rest must be verified with customer-managed keys
- Policy regression testing must prevent accidental privilege escalation

### Testing

**Security Testing Requirements:**

**RLS Policy Testing:**

- **Unauthorized Access Tests**: Comprehensive negative testing for all RLS policies
- **Cross-User Access Prevention**: Automated testing preventing user A from accessing user B's data
- **Service Role Limitation Tests**: Validation that service accounts cannot access PII
- **Policy Bypass Attempts**: Security testing for RLS policy circumvention

**Database Connection Security Testing:**

- **Certificate Pinning Validation**: Automated testing of certificate validation across platforms
- **SSL/TLS Configuration Tests**: Verification of minimum TLS 1.3 enforcement
- **Connection Pool Security**: Testing of security-first connection pool configuration
- **Firewall Rule Validation**: Automated testing of IP-based access restrictions

**Performance Testing with Security:**

- **RLS Query Performance**: Load testing of database queries with RLS enforcement
- **Connection Security Overhead**: Performance impact assessment of certificate pinning
- **Audit Logging Performance**: Impact testing of security audit logging on database performance

**Quality Gates:**

- [ ] All RLS policies prevent 100% of unauthorized access attempts in negative testing
- [ ] Certificate pinning verified and functional across web, iOS, and Android platforms
- [ ] Database audit logging captures security events with zero PII leakage
- [ ] Response time targets maintained (<200ms) with full RLS enforcement
- [ ] Policy regression testing prevents any reduction in security posture

**Pass/Fail Criteria:**

- **PASS:** All unauthorized access attempts blocked, certificate pinning functional, audit logging operational, performance targets met
- **FAIL:** Any unauthorized access successful, certificate pinning failures, PII in audit logs, performance degradation

**Test Implementation Framework:**

- **Security Test Suite**: Custom RLS testing framework with comprehensive negative tests
- **CI/CD Integration**: GitHub Actions workflow with automated security gate validation
- **Manual Penetration Testing**: Quarterly security assessment with external validation
- **Continuous Monitoring**: Real-time security violation detection with immediate alerting

## Change Log

| Date       | Version | Description            | Author       |
| ---------- | ------- | ---------------------- | ------------ |
| 2025-09-04 | 1.0     | Initial story creation | Scrum Master |
